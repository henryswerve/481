#exercise 0

def github() -> str:
    """
    comment
    """
    return "https://github.com/henryswerve/481.git"

#exercise 1

import numpy
import pandas
import scipy
import matplotlib
import seaborn

#exercise 2 DONE


n = 4
    
def evens_and_odds(n: int) -> dict:
    """
    """
    evensum = 0
    oddsum = 0
    dict_1 = {
    'evens': [],
    'odds': [],
    }
    
    for i in range(n):
        if i % 2 == 0:
            evensum += i
        else:
            oddsum += i
    dict_1['evens'].append(evensum)
    dict_1['odds'].append(oddsum)
    return dict_1

print(evens_and_odds(n))

#exercise 3 eh out? meaning? explain?

# Please write a function called time_diff that takes as arguments 
# two strings in the format ‘YYYY-MM-DD’ 
# and a keyword out dictating the output. If the keyword is “float”, 
# return the time between the two dates (in absolute value) in days. 
# If the keyword is “string”, return “There are XX days between the two dates”. 
# If not specified, the out keyword should be assumed to be “float”. 
# You should use the datetime package, and no others.

# For example, time_diff('2020-01-01', '2020-01-02', 'float') should return
# 1

# For example, time_diff('2020-01-03', '2020-01-01', 'string') should return

# "There are 2 days between the two dates"

from typing import Union
import datetime

#yr month day

date_1 = datetime.date(2020, 1, 1)

date_2 = datetime.date(2020, 1, 2)

#formats date_1 and date_2 to correct format
date_1.strftime("%Y-%m-%d")

date_2.strftime("%Y-%m-%d")

out = "string"
# date_1 + out 
# how to fix?

def time_diff(date_1: str, date_2: str, out: str) -> Union[str,float]:
    """
    Some docstrings.
    """
    delta = date_1 - date_2
    delta_3 = date_3 - date_1
    date_3 = datetime.date(2020, 1, 3)
    date_3.strftime("%Y-%m-%d")

    if delta < 0:
        delta = abs(delta)
    elif delta_3 < 0:
        delta_3 = abs(delta_3)
    else:
        None
    
    if delta_3 > 1:
        output_string = "There are {delta_3} days between the dates"
    elif delta_3 == 1:
        delta_3
    elif delta > 1:
        output_string_2 = "There are {delta} days between the dates"
    elif delta == 1:
        delta
    else:
        None

    return None
# want to return something that checks second ifelse block, 
# includes output_strings with dates associated with them

# def time_diff(date_1: str, date_2: str, out: str) -> Union[str,float]:
#     """
#     """
#     date_3 = datetime.date(2020, 1, 3)
#     date_3.strftime("%Y-%m-%d")
#     delta = date_1 - date_2
#     delta_3 = date_3 - date_1

#     if delta or delta_3 < 0:
#         delta = delta * -1
#         delta_3 = delta_3 * -1
#     else:
#         delta
#         delta_3
    
#     #
#     if out == "float":
#         output_string_1 = "There are {delta_3} days between the two dates"
#     else:
#         output_string_2 = delta

#     return output_string_1, output_string_2

# print(time_diff())

#exercise 4 DONE

in_list = ['a', 'b', 'c']

def reverse(in_list: list) -> list:
    """
    want to reverse order of list.
    """
    newlist = []
    newlist = list(reversed(in_list))
    
    return newlist

results_4 = reverse(in_list)

print(results_4)

#exercise 5 almost, got coef. done, prob?

# Write a function called prob_k_heads that takes as its arguments natural numbers n 
# and k with n>k and returns the probability of getting k heads from n flips 3.

#this is a binomial distribution

# (n!/k!(n-k)!) * p^x * q^n-x

# For example, prob_k_heads(1,1) should return

# .5
# using slide code
# p^x * q^n-x
n = 0
k = 0
binom_value = 0
prob = 0

def prob_k_heads(n: int, k: int) -> float:
    """
    """

    # binom coef (n choose k part is done, 
    # n_minus_k_fac is the value returned)
    n_minus_k_fac = 1
    for i in range(1, n-k+2):
        n_minus_k_fac *= i
    n_choose_k = 1
    for i in range(k+1, n+1):
        n_choose_k *= i
    n_choose_k /= n_minus_k_fac

    # p^x * q^n-x
    prob_success = 0
    prob_failure = 0

    # for i in range(n, ):
    #     aaaaaa = 0

    return n_minus_k_fac 

# for now, should eventually return variable prob